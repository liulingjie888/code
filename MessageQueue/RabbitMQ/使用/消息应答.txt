问题：
当消息队列发送给消费者后，队列就会将消息在内存中删除，如果此时消费者还没处理完消息就挂掉了，那么这个消息就丢失了。

消息应答
当autoAck为false时，对于RabbitMQ服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者ack信号的消息。如果服务器端一直没有收到消费者的ack信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者），因为只有consumer向broker发送了ack，broker才会删除消息，所以此时broker并没有删除消息，如果消费者再次正常消费，依然可以获得消息。

消息拒绝
消息在确认之前，可以有两个选择：
选择1：断开与rabbimq的连接，这样rabbimq会重新把消息分派给另一个消费者；
选择2：拒绝rabbimq发送的消息使用channel.basicReject(long deliveryTag, boolean requeue)，参数1：消息的id；参数2：处理消息的方式，如果是true，rabbimq会重新分配这个消息给其他订阅者，如果设置成false的话，rabbimq会把消息发送到一个特殊的“死信”队列，用来存放被拒绝而不重新放入队列的消息

消息持久化
消息应答的手动模式解决了消费者挂掉后消息会丢失的问题，但是如果rabbitmq挂掉了呢，消息仍然还会丢失。所以我们希望在重启rabbitmq后仍然可以拿到这些消息，这就需要用到消息持久化。
此时就需要把channel.queueDeclare()的第二个参数durable设置为true，即设置消息持久化。rabbitmq的队列拿到消息后会将消息保存到Erlang的数据库中，也可以理解为保存到磁盘上，重启rabbitmq会重新读取消息。

问题：
现在我们把channel.queueDeclare()的durable从false改为true，并启动生产者和消费者，发现报错了。
这是因为rabbitmq不允许重新定义一个已存在的队列，解决的办法是在Web控制台删除队列再重新声明或者声明一个新的队列即可。
