异常
try				//try里面检测异常
{
	throw  类型（类名（））;
}
catch(类型（类名 &引用名）		//捕捉异常并进行相应处理
{
	..........;
}

在try和catch块中定义的变量在块外不可用；

抛出异常后，跳过后面语句，直接去匹配catch,处理成功不会返回抛出位置而是继续往下执行；

若抛出的异常在该函数中的catch均无匹配，则回到该函数起点，在上一外层函数与catch匹配，如此反复
如没有捕捉到程序则终止；

在函数声明的形参表后列出该函数可能抛出的异常类型，例：
void  num(形参 ,形参 )throw(异常类型1，异常类型2，· · · ·）//该函数可能会抛出这些类型的异常
void  num(形参 ,形参 )throw()		//该函数不会抛出异常
void  num(形参 ,形参 )		//该函数可能抛出任何类型的异常

普通类会在捕捉异常前完成析构，异常类抛出后，执行完相应catch块后才析构；

catch通常采用异常类引用来接收异常，用异常类名接受会调用拷贝构造函数进行对象复制，降低运行效率；

重抛异常：如一层try-catch块中有多层try-catch，内层的异常需要外层来处理，可通过内层try-catch的catch
再次将异常抛出,例：
try
{
         try
         {
	throw 0;
          }
         catch(int)
         {
                ` ` ` ` ;
                throw 0;
         }
}
catch(int)
{
         ` ` ` `;
}

普通方式重抛： try抛什么（派生类），catch抛什么（对应基类）
标准语法重抛：try抛什么，catch直接throw;
标准语法重抛一般用在异常类重抛，原因：
1。内层的try抛出了派生类对象异常，但接收异常的catch却使用了基类形参，catch结构又将异常按照基类类型
重新抛出，则会导致原有派生类异常对象的部分信息丢失，
2.抛出的类要进行新的拷贝，降低工作效率
而采用标准语法抛出的是当前捕获的异常，而不是新的拷贝

断言
头文件<cassert>
assert(逻辑条件);		//条件为真继续运行，条件为假断言失败且调用abort()函数终止程序
如禁止使用断言，在头文件前添加 #define NDEBUG即可